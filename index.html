<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering NestJS: From Express to Enterprise</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Prism CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

    <!-- External JS Libraries -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false, theme: 'default' });
    </script>

    <style>
        :root {
            --nestjs-red: #E0234E;
            --express-gray: #303030;
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #f72585;
            --sidebar-w: 280px;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f8f9fa;
        }

        /* Sidebar */
        #sidebar {
            width: var(--sidebar-w);
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            background: #ffffff;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            z-index: 1000;
            transition: 0.3s;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.05);
        }

        .brand-section {
            padding: 25px;
            background: linear-gradient(135deg, var(--nestjs-red), var(--secondary));
            color: white;
            margin-bottom: 15px;
        }

        .nav-group-label {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #adb5bd;
            padding: 15px 25px 5px;
            letter-spacing: 1px;
        }

        .nav-link {
            color: #495057;
            padding: 10px 25px;
            border-left: 4px solid transparent;
            transition: all 0.2s;
        }

        .nav-link:hover,
        .nav-link.active {
            color: var(--nestjs-red);
            background: #fff5f7;
            border-left-color: var(--nestjs-red);
        }

        /* Main Content */
        main {
            margin-left: var(--sidebar-w);
            padding: 40px;
            transition: 0.3s;
        }

        /* Topic Cards */
        .topic-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 30px;
            overflow: hidden;
            border-top: 5px solid var(--nestjs-red);
        }

        .topic-header {
            padding: 20px 30px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .topic-header:hover {
            background-color: #fdfdfd;
        }

        .content-body {
            padding: 30px;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        /* Elements */
        .concept-box {
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .cb-red {
            background: #fff0f3;
            border-color: var(--nestjs-red);
        }

        .cb-blue {
            background: #e3f2fd;
            border-color: var(--primary);
        }

        .cb-gray {
            background: #f8f9fa;
            border-color: var(--express-gray);
        }

        .diagram-container {
            background: #fafafa;
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            overflow-x: auto;
        }

        /* Migration Badge */
        .migration-badge {
            background: linear-gradient(90deg, var(--express-gray) 0%, var(--nestjs-red) 100%);
            color: white;
            font-size: 0.7rem;
            padding: 4px 10px;
            border-radius: 20px;
            margin-left: 10px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Mobile */
        .toggle-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1100;
            border-radius: 50%;
            width: 50px;
            height: 50px;
        }

        @media (max-width: 991px) {
            #sidebar {
                transform: translateX(-100%);
            }

            #sidebar.active {
                transform: translateX(0);
            }

            main {
                margin-left: 0;
                padding: 20px;
            }

            .toggle-btn {
                display: block;
            }
        }
    </style>
</head>

<body>

    <button class="btn btn-danger toggle-btn shadow-lg" onclick="toggleSidebar()"><i class="fas fa-bars"></i></button>

    <!-- Sidebar -->
    <nav id="sidebar">
        <div class="brand-section">
            <h4 class="mb-0 fw-bold"><i class="fas fa-shield-cat me-2"></i>NestJS Master</h4>
            <small style="opacity: 0.9;">Express to Enterprise</small>
        </div>

        <div class="nav flex-column">
            <div class="nav-group-label">Phase 1: Foundations</div>
            <a href="#intro" class="nav-link">1. Why NestJS?</a>
            <a href="#architecture" class="nav-link">2. Core Architecture</a>
            <a href="#cli" class="nav-link">3. CLI & Setup</a>

            <div class="nav-group-label">Phase 2: Building Blocks</div>
            <a href="#controllers" class="nav-link">4. Controllers & Routing</a>
            <a href="#providers" class="nav-link">5. Providers & Services</a>
            <a href="#modules" class="nav-link">6. Modules & DI</a>

            <div class="nav-group-label">Phase 3: Migration Guide</div>
            <a href="#middleware" class="nav-link">7. Middleware (Express vs Nest)</a>
            <a href="#pipes" class="nav-link">8. Validation & Pipes</a>
            <a href="#guards" class="nav-link">9. Guards & Auth</a>
            <a href="#interceptors" class="nav-link">10. Interceptors</a>
            <a href="#errors" class="nav-link">10.5 Error Handling</a>
            <a href="#responses" class="nav-link">10.6 Consistent API Responses</a>

            <div class="nav-group-label">Phase 4: Advanced</div>
            <a href="#database" class="nav-link">11. Database (TypeORM/Prisma)</a>
            <a href="#config" class="nav-link">12. Configuration</a>
            <a href="#testing" class="nav-link">13. Testing</a>
            <a href="#microservices" class="nav-link">14. Microservices</a>
            <a href="#swagger" class="nav-link">15. API Documentation (Swagger)</a>
            <a href="#queues" class="nav-link">16. Queues (Bull/Redis)</a>
            <a href="#decorators" class="nav-link">17. Custom Decorators</a>
            <a href="#versioning" class="nav-link">18. API Versioning</a>
            <a href="#structure" class="nav-link">19. Project Structure</a>
            <a href="#websockets" class="nav-link">20. Real-Time (WebSockets)</a>
        </div>
    </nav>

    <!-- Main Content -->
    <main>

        <!-- Introduction -->
        <div class="alert alert-light border-start border-4 border-danger mb-5 shadow-sm">
            <div class="row align-items-center">
                <div class="col-md-9">
                    <h1 class="display-6 fw-bold text-dark">Learning Path: NestJS for Express Developers</h1>
                    <p class="lead text-muted">A structured guide to transitioning from the freedom of Express.js to the
                        opinionated, scalable architecture of NestJS.</p>
                    <hr class="my-3">
                    <div class="row g-3 small text-muted">
                        <div class="col-md-6">
                            <i class="fas fa-calendar-alt text-danger me-2"></i>
                            <strong>Last Updated:</strong> <span id="lastUpdated">Loading...</span>
                        </div>
                        <div class="col-md-6">
                            <i class="fas fa-building text-danger me-2"></i>
                            <strong>Organization:</strong> Techversant Infotech
                        </div>
                    </div>
                </div>
                <div class="col-md-3 text-center">
                    <img src="https://techversantinfotech.com/wp-content/uploads/2025/09/Techv-logo-011-scaled.png"
                        alt="Techversant Infotech Logo" class="img-fluid rounded shadow-sm" style="max-width: 150px;">
                </div>
            </div>
        </div>

        <script>
            // Set last updated date
            document.getElementById('lastUpdated').textContent = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        </script>

        <!-- 1. Why NestJS? -->
        <section id="intro" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-rocket me-2 text-danger"></i>1. Why NestJS? (The Paradigm
                    Shift)</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro Concept -->
                <div class="row align-items-center mb-4">
                    <div class="col-md-7">
                        <p class="lead text-dark">Node.js is powerful, but <strong>Express.js</strong> leaves
                            architectural decisions entirely up to you. This freedom often leads to "Spaghetti Code" in
                            large enterprise applications.</p>
                        <p class="text-muted"><strong>NestJS</strong> solves this. It provides an out-of-the-box
                            architecture inspired by Angular. It forces you to write code that is modular, testable, and
                            scalable.</p>
                    </div>
                    <div class="col-md-5">
                        <div class="concept-box cb-red">
                            <h6 class="fw-bold text-danger">The Core Philosophy</h6>
                            <ul class="small mb-0 ps-3">
                                <li><strong>Opinionated:</strong> Provides a "right way" to do things.</li>
                                <li><strong>TypeScript First:</strong> Built with and for TS (though JS is supported).
                                </li>
                                <li><strong>OOP + FP + FRP:</strong> Combines Object Oriented, Functional, and Reactive
                                    programming.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Visual Comparison: Express vs Nest Architecture -->
                <h6 class="fw-bold text-secondary mt-4">1.1 Visualizing the Architecture Shift</h6>
                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="card h-100 border-0 bg-light">
                            <div class="card-header bg-dark text-white text-center">
                                <i class="fab fa-node-js me-2"></i>Express.js (The "Wild West")
                            </div>
                            <div class="card-body">
                                <div class="diagram-container m-0 p-2">
                                    <div class="mermaid">
                                        graph TD
                                        Req[Request] --> MW[Middleware]
                                        MW --> Route[Route Handler]
                                        Route --> DB[(Database)]
                                        Route --> Util[Helper Functions]
                                        style Route fill:#fff,stroke:#333
                                        style DB fill:#eee,stroke:#333
                                    </div>
                                </div>
                                <p class="small text-center mt-2">Linear, often unstructured. No strict rules on folder
                                    structure or dependency management.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-0 bg-light">
                            <div class="card-header text-white text-center"
                                style="background-color: var(--nestjs-red);">
                                <i class="fas fa-shield-cat me-2"></i>NestJS (The "Structured City")
                            </div>
                            <div class="card-body">
                                <div class="diagram-container m-0 p-2">
                                    <div class="mermaid">
                                        graph TD
                                        Root[App Module] --> UserMod[User Module]
                                        Root --> OrderMod[Order Module]

                                        subgraph User Module
                                        C1[Controller] <--> S1[Service]
                                            end

                                            subgraph Order Module
                                            C2[Controller] <--> S2[Service]
                                                end

                                                style Root fill:#E0234E,color:white,stroke:#333
                                                style UserMod fill:#ffcdd2,stroke:#E0234E
                                                style OrderMod fill:#ffcdd2,stroke:#E0234E
                                    </div>
                                </div>
                                <p class="small text-center mt-2">Modular, hierarchical. Logic is separated into
                                    Modules, Controllers, and Providers.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <hr class="my-4">

                <!-- Scalability Chart -->
                <div class="row align-items-center">
                    <div class="col-md-7">
                        <h6 class="fw-bold text-secondary">1.2 Scalability vs. Development Time</h6>
                        <p class="small text-muted">
                            Express is faster to start (Boilerplate is minimal). However, as the project grows, the lack
                            of structure increases technical debt ("Maintenance Nightmare").
                            <br><br>
                            NestJS has a steeper learning curve initially, but maintainability remains constant as the
                            app scales.
                        </p>
                    </div>
                    <div class="col-md-5">
                        <div style="height: 250px;">
                            <canvas id="frameworkChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Comparison Table -->
                <h6 class="fw-bold text-secondary mt-4">1.3 Direct Comparison</h6>
                <div class="table-responsive">
                    <table class="table table-hover table-bordered small align-middle">
                        <thead class="table-dark">
                            <tr>
                                <th>Feature</th>
                                <th>Express.js</th>
                                <th>NestJS</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="fw-bold">Architecture</td>
                                <td>Unopinionated (DIY)</td>
                                <td>Modular (Angular-inspired)</td>
                            </tr>
                            <tr>
                                <td class="fw-bold">Language</td>
                                <td>JavaScript (CommonJS)</td>
                                <td>TypeScript (First-class citizen)</td>
                            </tr>
                            <tr>
                                <td class="fw-bold">Dependency Injection</td>
                                <td>No (Manual require/import)</td>
                                <td>Yes (Built-in IoC Container)</td>
                            </tr>
                            <tr>
                                <td class="fw-bold">Use Case</td>
                                <td>Micro-services, Simple APIs</td>
                                <td>Enterprise Monoliths, Complex APIs</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Chart Script for this section -->
                <script>
                    (function () {
                        const ctx = document.getElementById('frameworkChart').getContext('2d');
                        new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: ['Start', 'Small App', 'Medium App', 'Enterprise App', 'Mega Monolith'],
                                datasets: [{
                                    label: 'Maintainability (NestJS)',
                                    data: [90, 92, 90, 88, 85],
                                    borderColor: '#E0234E',
                                    tension: 0.3,
                                    borderWidth: 3
                                }, {
                                    label: 'Maintainability (Express)',
                                    data: [100, 95, 75, 50, 30],
                                    borderColor: '#303030',
                                    tension: 0.3,
                                    borderWidth: 3,
                                    borderDash: [5, 5]
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: { y: { beginAtZero: true, title: { display: true, text: 'Ease of Maintenance' } } },
                                plugins: { legend: { position: 'bottom' } }
                            }
                        });
                    })();
                </script>

            </div>
        </section>

        <!-- 2. Core Architecture -->
        <section id="architecture" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-cubes me-2 text-primary"></i>2. Core Architecture: The Module
                    System</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="lead text-dark">
                    In NestJS, everything is a <strong>Module</strong>. Unlike Express, where you might organize code by
                    folders (routes, models, controllers), NestJS organizes code by <strong>Domain</strong> (Features).
                </p>

                <!-- The Triad Visualization -->
                <h6 class="fw-bold text-secondary mt-4">2.1 The Building Blocks (The Triad)</h6>
                <div class="row g-3 mb-4">

                    <!-- Modules -->
                    <div class="col-md-4">
                        <div class="concept-box cb-red h-100">
                            <h6 class="fw-bold text-danger"><i class="fas fa-box me-2"></i>1. Modules</h6>
                            <p class="small text-muted">The organizational unit. Every application has at least one
                                <strong>Root Module</strong>. It groups related controllers and providers together.
                            </p>
                            <span class="badge bg-danger">@Module()</span>
                        </div>
                    </div>

                    <!-- Controllers -->
                    <div class="col-md-4">
                        <div class="concept-box cb-blue h-100">
                            <h6 class="fw-bold text-primary"><i class="fas fa-traffic-light me-2"></i>2. Controllers
                            </h6>
                            <p class="small text-muted">Responsible for handling incoming <strong>HTTP requests</strong>
                                and returning responses to the client. They bind routes to logic.</p>
                            <span class="badge bg-primary">@Controller()</span>
                        </div>
                    </div>

                    <!-- Providers -->
                    <div class="col-md-4">
                        <div class="concept-box cb-gray h-100">
                            <h6 class="fw-bold text-dark"><i class="fas fa-concierge-bell me-2"></i>3. Providers</h6>
                            <p class="small text-muted">Also known as Services. They contain the <strong>Business
                                    Logic</strong>. They are injected into controllers via Dependency Injection.</p>
                            <span class="badge bg-dark">@Injectable()</span>
                        </div>
                    </div>
                </div>

                <!-- Interactive Logic Diagram -->
                <h6 class="fw-bold text-secondary">2.2 The Application Graph</h6>
                <p class="small text-muted">NestJS constructs an "Application Graph" at startup. This determines how
                    modules connect and how dependencies are instantiated.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        graph TD
                        Client((Client)) -- HTTP Request --> Root[App Module]

                        subgraph App Module
                        AC[AppController]
                        AS[AppService]
                        AC --> AS
                        end

                        subgraph Users Feature
                        Root --> UM[UsersModule]
                        UC[UsersController]
                        US[UsersService]
                        UM --> UC
                        UC --> US
                        US --> DB[(Database)]
                        end

                        subgraph Auth Feature
                        Root --> AM[AuthModule]
                        AC_Auth[AuthController]
                        AS_Auth[AuthService]
                        AM --> AC_Auth
                        AC_Auth --> AS_Auth
                        end

                        style Root fill:#E0234E,color:white,stroke:#333
                        style UM fill:#ffebee,stroke:#E0234E
                        style AM fill:#e3f2fd,stroke:#2196f3
                        style US fill:#fff,stroke:#333
                        style AS fill:#fff,stroke:#333
                        style DB fill:#333,color:white
                    </div>
                </div>

                <!-- Code Example vs Express -->
                <div class="row mt-4">
                    <div class="col-12">
                        <h6 class="fw-bold text-secondary">2.3 How it looks in Code</h6>
                    </div>
                    <div class="col-md-6">
                        <div class="p-3 bg-light border rounded">
                            <h6 class="small text-muted fw-bold text-uppercase">NestJS (Declarative)</h6>
                            <pre class="m-0" style="font-size: 0.75rem;"><code class="language-typescript">
// app.module.ts
@Module({
  imports: [UsersModule, AuthModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
                            </code></pre>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="p-3 bg-light border rounded">
                            <h6 class="small text-muted fw-bold text-uppercase">Express (Imperative)</h6>
                            <pre class="m-0" style="font-size: 0.75rem;"><code class="language-javascript">
// app.js
const express = require('express');
const app = express();

const userRoutes = require('./routes/users');
const authRoutes = require('./routes/auth');

// Manually wiring routes
app.use('/users', userRoutes);
app.use('/auth', authRoutes);
                            </code></pre>
                        </div>
                    </div>
                </div>

                <!-- Key Takeaway -->
                <div class="alert alert-info mt-4 d-flex align-items-center">
                    <i class="fas fa-lightbulb fa-2x me-3"></i>
                    <div>
                        <strong>Inversion of Control (IoC):</strong> In Express, <em>you</em> create instances of your
                        services and pass them around. In NestJS, the <em>IoC Container</em> creates and manages
                        instances for you (Singleton pattern by default).
                    </div>
                </div>

            </div>
        </section>

        <!-- 3. CLI -->
        <section id="cli" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-terminal me-2 text-dark"></i>3. CLI & Project Scaffolding</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted mb-4">
                    In Express, you start with a blank file and build your own structure. In NestJS, the <strong>CLI
                        (Command Line Interface)</strong> is your best friend. It not only creates the project but
                    generates code, updates modules, and ensures architectural consistency.
                </p>

                <!-- Terminal Simulation -->
                <div class="row mb-4">
                    <div class="col-md-8 mx-auto">
                        <div class="card bg-dark text-white border-0 shadow">
                            <div class="card-header border-secondary p-2 small">
                                <span class="text-danger me-2">●</span>
                                <span class="text-warning me-2">●</span>
                                <span class="text-success">●</span>
                                <span class="ms-2 text-muted">bash</span>
                            </div>
                            <div class="card-body font-monospace p-3">
                                <p class="mb-2"><span class="text-success">$</span> npm i -g @nestjs/cli <span
                                        class="text-secondary">// Install Global CLI</span></p>
                                <p class="mb-2"><span class="text-success">$</span> nest new project-name <span
                                        class="text-secondary">// Scaffolds entire app</span></p>
                                <p class="mb-0"><span class="text-success">$</span> npm run start:dev <span
                                        class="text-secondary">// Hot-reload server</span></p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Directory Structure Comparison -->
                <h6 class="fw-bold text-secondary mt-4">3.1 Structure Comparison: Express vs. Nest</h6>
                <p class="small text-muted">See how NestJS enforces a specific structure compared to the flexibility of
                    Express.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        graph TD
                        subgraph Express["Express (Common Convention)"]
                        ERoot[root]
                        EApp[app.js]
                        ERoutes[routes/]
                        EControllers[controllers/]
                        EModels[models/]
                        ERoot --> EApp
                        ERoot --> ERoutes
                        ERoot --> EControllers
                        ERoot --> EModels
                        end

                        subgraph Nest["NestJS (Standard)"]
                        NRoot[root]
                        NMain[main.ts]
                        NAppMod[app.module.ts]
                        NAppCon[app.controller.ts]
                        NAppSrv[app.service.ts]
                        NUsers[users/]

                        NRoot --> src
                        src --> NMain
                        src --> NAppMod
                        src --> NAppCon
                        src --> NAppSrv
                        src --> NUsers
                        end

                        style Express fill:#f8f9fa,stroke:#333
                        style Nest fill:#fff0f3,stroke:#E0234E
                        style NMain fill:#E0234E,color:white
                        style NAppMod fill:#E0234E,color:white
                    </div>
                </div>

                <!-- The Generator Table -->
                <h6 class="fw-bold text-secondary mt-4">3.2 The Generator (Productivity Booster)</h6>
                <p class="small text-muted">
                    Stop creating files manually! The CLI creates the file, the spec (test) file, and
                    <strong>automatically imports it into the Module</strong>.
                </p>

                <div class="table-responsive">
                    <table class="table table-hover align-middle small">
                        <thead class="table-light">
                            <tr>
                                <th>Goal</th>
                                <th>Express Workflow</th>
                                <th>Nest CLI Command</th>
                                <th>Outcome</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="fw-bold">New Feature</td>
                                <td>Create folder, create files manually</td>
                                <td><code class="text-danger">nest g res users</code></td>
                                <td>Creates Module, Controller, Service, DTOs & Entities (CRUD ready)</td>
                            </tr>
                            <tr>
                                <td class="fw-bold">New Route</td>
                                <td>Create file in <code>routes/</code>, require in <code>app.js</code></td>
                                <td><code class="text-primary">nest g co orders</code></td>
                                <td>Creates Controller & updates Module imports</td>
                            </tr>
                            <tr>
                                <td class="fw-bold">Business Logic</td>
                                <td>Create file in <code>services/</code></td>
                                <td><code class="text-warning">nest g s orders</code></td>
                                <td>Creates Service & updates Module providers</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Key Concept Box -->
                <div class="concept-box cb-blue mt-3">
                    <h6 class="fw-bold text-primary mb-1">main.ts - The Entry Point</h6>
                    <p class="small text-muted mb-0">
                        Unlike Express where <code>app.js</code> usually contains middleware, routes, and server
                        startup, NestJS uses <code>main.ts</code> purely to bootstrap the application factory. Logic is
                        delegated to Modules.
                    </p>
                </div>

            </div>
        </section>

        <!-- 4. Controllers -->
        <section id="controllers" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-route me-2 text-success"></i>4. Controllers & Routing
                    <span class="migration-badge">Express: app.get()</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Explanation -->
                <p class="text-muted">
                    Controllers are responsible for handling incoming <strong>requests</strong> and returning
                    <strong>responses</strong> to the client. In Express, you define routes manually. In NestJS, you use
                    <strong>Classes</strong> and <strong>Decorators</strong>.
                </p>

                <!-- Comparison Code Block -->
                <div class="row g-3 mb-4">
                    <!-- Express Side -->
                    <div class="col-md-6">
                        <div class="p-3 bg-light border rounded h-100">
                            <div class="d-flex align-items-center mb-2">
                                <i class="fab fa-node-js fa-lg me-2"></i>
                                <h6 class="fw-bold m-0">Express.js</h6>
                            </div>
                            <pre class="m-0" style="font-size: 0.75rem;"><code class="language-javascript">
// user.routes.js
router.get('/users', (req, res) => {
  res.json({ message: 'Get all users' });
});

router.post('/users', (req, res) => {
  // Access body via req.body
  const user = req.body;
  res.status(201).json(user);
});
                            </code></pre>
                        </div>
                    </div>

                    <!-- NestJS Side -->
                    <div class="col-md-6">
                        <div class="p-3 border rounded h-100"
                            style="background-color: #f0fff4; border-color: #c3e6cb !important;">
                            <div class="d-flex align-items-center mb-2">
                                <i class="fas fa-shield-cat fa-lg text-success me-2"></i>
                                <h6 class="fw-bold m-0 text-success">NestJS</h6>
                            </div>
                            <pre class="m-0" style="font-size: 0.75rem;"><code class="language-typescript">
// user.controller.ts
@Controller('users')
export class UserController {

  @Get()
  findAll() {
    return { message: 'Get all users' };
  }

  @Post()
  @HttpCode(201)
  create(@Body() user: CreateUserDto) {
    return user;
  }
}
                            </code></pre>
                        </div>
                    </div>
                </div>

                <!-- Decorator Mapping Table -->
                <h6 class="fw-bold text-secondary mt-2">4.1 Decorator Cheat Sheet</h6>
                <div class="table-responsive mb-4">
                    <table class="table table-sm table-bordered align-middle">
                        <thead class="table-light">
                            <tr>
                                <th>Express Concept</th>
                                <th>NestJS Decorator</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>req.body</code></td>
                                <td><code class="text-danger">@Body()</code></td>
                                <td>Extracts the body of the request.</td>
                            </tr>
                            <tr>
                                <td><code>req.params</code></td>
                                <td><code class="text-primary">@Param()</code></td>
                                <td>Extracts route parameters (e.g., <code>/users/:id</code>).</td>
                            </tr>
                            <tr>
                                <td><code>req.query</code></td>
                                <td><code class="text-info">@Query()</code></td>
                                <td>Extracts query strings (e.g., <code>?limit=10</code>).</td>
                            </tr>
                            <tr>
                                <td><code>res.status()</code></td>
                                <td><code class="text-warning">@HttpCode()</code></td>
                                <td>Sets the HTTP status code explicitly.</td>
                            </tr>
                            <tr>
                                <td><code>req, res</code></td>
                                <td><code>@Req(), @Res()</code></td>
                                <td>Access underlying platform objects (Avoid if possible!).</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Request Lifecycle Diagram -->
                <h6 class="fw-bold text-secondary">4.2 The Lifecycle of a Request</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        sequenceDiagram
                        participant C as Client
                        participant Con as Controller (@Controller)
                        participant H as Handler (@Get/Post)
                        participant S as Service

                        C->>Con: HTTP GET /users
                        Con->>H: Match Route Route
                        H->>S: Call Business Logic
                        S-->>H: Return Data
                        H-->>C: Auto-Serialize JSON Response
                    </div>
                </div>

                <!-- DTO Concept -->
                <div class="concept-box cb-blue mt-4">
                    <h6 class="fw-bold text-primary mb-2">DTO (Data Transfer Object)</h6>
                    <p class="small text-muted mb-0">
                        In Express, you often guess what is in `req.body`. In NestJS, we use <strong>DTOs</strong>
                        (Classes) to define the shape of data sent over the network. This enables automatic validation
                        and IntelliSense.
                    </p>
                </div>

            </div>
        </section>

        <!-- 5. Providers -->
        <section id="providers" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-cogs me-2 text-warning"></i>5. Providers & Services
                    <span class="migration-badge">Express: Service Layer</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="lead text-dark">
                    A <strong>Provider</strong> is simply a class annotated with the <code>@Injectable()</code>
                    decorator. In Express, you might create a "service" file and manually <code>require()</code> it in
                    your controller. In NestJS, the framework <strong>injects</strong> these services for you.
                </p>

                <!-- Concept Visualization -->
                <div class="row align-items-center mb-4">
                    <div class="col-md-6">
                        <div class="concept-box cb-gray h-100">
                            <h6 class="fw-bold text-dark">Separation of Concerns</h6>
                            <ul class="small mb-0 ps-3">
                                <li><strong>Controllers:</strong> Handle HTTP requests and responses. They should be
                                    "thin".</li>
                                <li><strong>Services (Providers):</strong> Handle complex business logic and database
                                    access. They should be "fat".</li>
                            </ul>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="diagram-container m-0 p-2">
                            <div class="mermaid">
                                graph LR
                                C[Controller] -.->|Injects| S[Service]
                                S -.->|Injects| R[Repository]
                                R --> DB[(Database)]
                                style S fill:#fff3e0,stroke:#ff9800
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Code Comparison -->
                <h6 class="fw-bold text-secondary">5.1 The "Express Way" vs. The "Nest Way"</h6>
                <div class="row g-0 border rounded overflow-hidden mb-4">
                    <!-- Express -->
                    <div class="col-md-6 border-end bg-light p-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <strong class="text-muted small">Express (Manual Import)</strong>
                            <i class="fab fa-node-js text-muted"></i>
                        </div>
                        <pre class="m-0 border-0" style="font-size: 0.75rem;"><code class="language-javascript">
// userService.js
class UserService {
  findAll() { return db.users.find(); }
}
module.exports = new UserService();

// userController.js
// Tightly Coupled!
const userService = require('./userService');

const getUsers = (req, res) => {
   const users = userService.findAll();
   res.json(users);
}
                        </code></pre>
                    </div>

                    <!-- NestJS -->
                    <div class="col-md-6 bg-white p-3">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <strong class="text-warning small">NestJS (Dependency Injection)</strong>
                            <i class="fas fa-shield-alt text-warning"></i>
                        </div>
                        <pre class="m-0 border-0" style="font-size: 0.75rem;"><code class="language-typescript">
// user.service.ts
@Injectable()
export class UserService {
  findAll() { return db.users.find(); }
}

// user.controller.ts
@Controller('users')
export class UserController {
  // Loosely Coupled! Nest handles the "new"
  constructor(private userService: UserService) {}

  @Get()
  getUsers() {
     return this.userService.findAll();
  }
}
                        </code></pre>
                    </div>
                </div>

                <!-- How DI Works Diagram -->
                <h6 class="fw-bold text-secondary mt-4">5.2 How Dependency Injection (DI) Works</h6>
                <p class="small text-muted">NestJS uses a built-in IoC (Inversion of Control) container to manage
                    dependencies.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        sequenceDiagram
                        participant App as Nest Application
                        participant Cont as IoC Container
                        participant Srv as UserService
                        participant Ctrl as UserController

                        App->>Cont: Bootstrap Application
                        Cont->>Srv: Instantiate UserService
                        Note right of Srv: Singleton created (Cached)
                        Cont->>Ctrl: Instantiate UserController
                        Ctrl->>Cont: "I need UserService!"
                        Cont-->>Ctrl: Injects cached UserService instance
                    </div>
                </div>

                <!-- Key Benefits -->
                <div class="row g-2 mt-2">
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light text-center small">
                            <i class="fas fa-vial text-success mb-1"></i><br><strong>Testability</strong><br>Easily mock
                            services during testing.
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light text-center small">
                            <i class="fas fa-recycle text-info mb-1"></i><br><strong>Reusability</strong><br>Share logic
                            across modules effortlessly.
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light text-center small">
                            <i class="fas fa-memory text-danger mb-1"></i><br><strong>Efficiency</strong><br>Singletons
                            save memory usage.
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 6. Modules -->
        <section id="modules" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-box-open me-2 text-info"></i>6. Modules & Organization</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="lead text-dark">
                    A <strong>Module</strong> is a class annotated with the <code>@Module()</code> decorator. It
                    provides metadata that Nest uses to organize the application structure.
                </p>
                <div class="alert alert-light border-start border-4 border-info">
                    <strong>Express Mindset:</strong> "I organize code by file paths and folders."<br>
                    <strong>NestJS Mindset:</strong> "I organize code by logical <em>features</em> (Modules). The file
                    path doesn't determine visibility; the Module does."
                </div>

                <!-- The Application Graph Diagram -->
                <h6 class="fw-bold text-secondary mt-4">6.1 The Application Tree</h6>
                <p class="small text-muted">NestJS builds a graph starting from the <strong>Root Module</strong>.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        graph TD
                        Root[App Module]

                        subgraph Core [Core Features]
                        DB[Database Module]
                        Config[Config Module]
                        end

                        subgraph Features [Business Logic]
                        User[Users Module]
                        Order[Orders Module]
                        Chat[Chat Module]
                        end

                        subgraph Shared [Shared Utilities]
                        Auth[Auth Module]
                        end

                        Root --> DB
                        Root --> Config
                        Root --> User
                        Root --> Order
                        Root --> Chat

                        User -.->|Imports| Auth
                        Order -.->|Imports| Auth

                        style Root fill:#E0234E,color:white,stroke:#333
                        style Auth fill:#fff176,stroke:#fbc02d
                        style User fill:#e1f5fe,stroke:#0288d1
                        style Order fill:#e1f5fe,stroke:#0288d1
                    </div>
                </div>

                <!-- The @Module Metadata -->
                <h6 class="fw-bold text-secondary mt-4">6.2 Anatomy of a Module</h6>
                <p class="small">The decorator takes an object with four specific properties:</p>

                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="card h-100 border-primary shadow-sm">
                            <div class="card-body">
                                <h6 class="text-primary fw-bold">1. controllers</h6>
                                <p class="small mb-0">The set of controllers defined in this module which have to be
                                    instantiated.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-warning shadow-sm">
                            <div class="card-body">
                                <h6 class="text-warning fw-bold">2. providers</h6>
                                <p class="small mb-0">The services, repositories, or factories that will be instantiated
                                    by the Nest injector and may be shared at least within this module.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-success shadow-sm">
                            <div class="card-body">
                                <h6 class="text-success fw-bold">3. imports</h6>
                                <p class="small mb-0">The list of <em>other</em> modules that export the providers which
                                    are required in this module.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-danger shadow-sm">
                            <div class="card-body">
                                <h6 class="text-danger fw-bold">4. exports</h6>
                                <p class="small mb-0">The subset of providers that are provided by this module and
                                    should be available in other modules which import this module.
                                    <strong>(Encapsulation)</strong>.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Code Example: Shared Modules -->
                <h6 class="fw-bold text-secondary mt-4">6.3 Shared Modules (The "Gotcha" for Express Devs)</h6>
                <p class="small text-muted">
                    In Express, if you `require()` a file, you get it. In NestJS, Providers are <strong>private</strong>
                    to the module unless they are exported.
                </p>

                <div class="row g-0 border rounded overflow-hidden">
                    <div class="col-md-12 bg-white p-3">
                        <pre class="m-0 border-0" style="font-size: 0.8rem;"><code class="language-typescript">
// auth.module.ts
@Module({
  providers: [AuthService],
  exports: [AuthService] // <--- CRITICAL: Making it public
})
export class AuthModule {}


// users.module.ts
@Module({
  imports: [AuthModule], // <--- Importing the Module, NOT the service file
  controllers: [UserController],
  providers: [UserService]
  // UserService can now inject AuthService!
})
export class UsersModule {}
                        </code></pre>
                    </div>
                </div>

                <!-- Global Modules -->
                <div class="concept-box cb-blue mt-4">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-globe fa-2x text-primary me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">@Global() Modules</h6>
                            <p class="small text-muted m-0">
                                Usually, you must import a module to use it. However, for things like Database
                                connections or Loggers, you can use the <code>@Global()</code> decorator. You import it
                                once in the Root module, and it's available everywhere. Use sparingly!
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 7. Middleware -->
        <section id="middleware" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-filter me-2 text-secondary"></i>7. Middleware
                    <span class="migration-badge">Express: app.use()</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted mb-4">
                    Middleware is a function which is called <strong>before</strong> the route handler. Middleware
                    functions have access to the request and response objects, and the <code>next()</code> middleware
                    function in the application’s request-response cycle.
                </p>

                <!-- Comparison -->
                <div class="row g-4 align-items-center mb-4">
                    <!-- Express -->
                    <div class="col-md-5">
                        <div class="card h-100 border-0">
                            <div class="card-header bg-dark text-white small">Express.js Logic</div>
                            <div class="card-body bg-dark">
                                <pre class="m-0 p-0 border-0"><code class="language-javascript">
app.use((req, res, next) => {
  console.log('Request...');
  next();
});
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-2 text-center text-muted">
                        <i class="fas fa-arrow-right fa-2x d-none d-md-block"></i>
                        <i class="fas fa-arrow-down fa-2x d-md-none"></i>
                    </div>

                    <!-- NestJS -->
                    <div class="col-md-5">
                        <div class="card h-100 border-secondary">
                            <div class="card-header bg-secondary text-white small">NestJS Logic</div>
                            <div class="card-body">
                                <p class="small mb-1">NestJS supports <strong>both</strong> functional and class-based
                                    middleware.</p>
                                <span class="badge bg-secondary mb-2">NestMiddleware Interface</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Class Middleware Example -->
                <h6 class="fw-bold text-secondary">7.1 Class-based Middleware (The Nest Way)</h6>
                <p class="small text-muted">Why Class-based? Because you can use <strong>Dependency Injection</strong>
                    inside them!</p>

                <pre class="rounded"><code class="language-typescript">
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  constructor(private readonly loggerService: LoggerService) {} // DI works here!

  use(req: Request, res: Response, next: NextFunction) {
    this.loggerService.log(`Request to: ${req.originalUrl}`);
    next();
  }
}
                </code></pre>

                <!-- Applying Middleware -->
                <h6 class="fw-bold text-secondary mt-4">7.2 Applying Middleware (The Consumer)</h6>
                <p class="small text-muted">Unlike decorators used for Guards or Interceptors, Middleware is configured
                    in the <strong>Module's <code>configure()</code> method</strong>.</p>

                <div class="diagram-container m-0 p-3 mb-3">
                    <div class="mermaid">
                        graph LR
                        Req[HTTP Request] --> Global[Global Middleware]
                        Global --> Module[Module Middleware]
                        Module --> Route[Route Handler]

                        style Global fill:#e0e0e0,stroke:#333
                        style Module fill:#b3e5fc,stroke:#0288d1
                        style Route fill:#c8e6c9,stroke:#388e3c
                    </div>
                </div>

                <pre class="rounded"><code class="language-typescript">
// app.module.ts
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(LoggerMiddleware)
      .exclude(
        { path: 'cats', method: RequestMethod.GET }, // Exclude specific routes
        'cats/(.*)',
      )
      .forRoutes('cats'); // Apply to all routes in CatsController
  }
}
                </code></pre>

                <!-- Functional Middleware -->
                <div class="concept-box cb-gray mt-4">
                    <h6 class="fw-bold text-dark">Functional Middleware</h6>
                    <p class="small text-muted mb-2">If your middleware doesn't need dependencies, you can just use a
                        simple function, exactly like Express.</p>
                    <pre class="m-0 border p-2 rounded"><code class="language-typescript">export function logger(req, res, next) {
  console.log(`Request...`);
  next();
};</code></pre>
                </div>

                <!-- Global Middleware Warning -->
                <div class="alert alert-warning d-flex align-items-center mt-3" role="alert">
                    <i class="fas fa-exclamation-triangle me-3 fa-lg"></i>
                    <div>
                        <strong>Global Middleware Note:</strong> Unlike other global components, Global Middleware
                        defined in <code>main.ts</code> via <code>app.use()</code> <strong>cannot</strong> inject
                        dependencies. If you need DI, bind it in the Root Module instead.
                    </div>
                </div>

            </div>
        </section>

        <!-- 8. Pipes -->
        <section id="pipes" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-check-double me-2 text-danger"></i>8. Validation & Pipes
                    <span class="migration-badge">Express: Joi / Express-Validator</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    A <strong>Pipe</strong> is a class annotated with <code>@Injectable()</code>. Pipes operate on the
                    <strong>arguments</strong> being processed by a controller route handler. They have two typical use
                    cases:
                </p>
                <div class="row g-2 mb-4">
                    <div class="col-md-6">
                        <div class="p-3 border rounded bg-light border-start border-4 border-primary">
                            <strong class="text-primary">1. Transformation</strong><br>
                            Transform input data to the desired form (e.g., from string <code>"1"</code> to integer
                            <code>1</code>).
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="p-3 border rounded bg-light border-start border-4 border-danger">
                            <strong class="text-danger">2. Validation</strong><br>
                            Evaluate input data and if valid, pass it through unchanged; otherwise, throw an exception.
                        </div>
                    </div>
                </div>

                <!-- Workflow Diagram -->
                <h6 class="fw-bold text-secondary">8.1 Where do Pipes sit?</h6>
                <p class="small text-muted">Pipes run <em>inside</em> the exception zone. If a Pipe throws an error
                    (e.g., Validation Error), the controller method is <strong>never executed</strong>.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Req[HTTP Request] --> Guard[Guards]
                        Guard --> Pipe{Pipes}

                        Pipe -->|Valid / Transformed| Ctrl[Controller Handler]
                        Pipe --x|Invalid Data| Ex[Exception Filter]
                        Ex -->|400 Bad Request| Res[Response]

                        style Pipe fill:#ffcdd2,stroke:#d32f2f
                        style Ctrl fill:#c8e6c9,stroke:#388e3c
                        style Ex fill:#ffecb3,stroke:#ffb300
                    </div>
                </div>

                <!-- Built-in Pipes -->
                <h6 class="fw-bold text-secondary mt-4">8.2 Transformation (Built-in Pipes)</h6>
                <p class="small text-muted">
                    In Express, you often do <code>const id = parseInt(req.params.id)</code> inside your route. In
                    NestJS, you declare it.
                </p>

                <div class="row">
                    <div class="col-md-6">
                        <ul class="list-group list-group-flush small">
                            <li class="list-group-item"><code>ParseIntPipe</code></li>
                            <li class="list-group-item"><code>ParseBoolPipe</code></li>
                            <li class="list-group-item"><code>ParseUUIDPipe</code></li>
                            <li class="list-group-item"><code>DefaultValuePipe</code></li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <pre class="m-0 rounded"><code class="language-typescript">
@Get(':id')
// Auto-converts "123" string to number
// Throws 400 if ID is "abc"
findOne(@Param('id', ParseIntPipe) id: number) {
  return this.usersService.findOne(id);
}
                        </code></pre>
                    </div>
                </div>

                <hr class="my-4">

                <!-- Schema Validation -->
                <h6 class="fw-bold text-danger">8.3 Schema Validation (The "Killer Feature")</h6>
                <p class="small">
                    Express often uses libraries like <strong>Joi</strong> or <strong>Zod</strong> with middleware.
                    NestJS leverages <strong>class-validator</strong> and <strong>class-transformer</strong> to validate
                    data based on the DTO class definition.
                </p>

                <!-- Comparison -->
                <div class="row g-3">
                    <!-- Step 1: The DTO -->
                    <div class="col-md-6">
                        <div class="card h-100 border-secondary">
                            <div class="card-header bg-secondary text-white small">Step 1: Define DTO</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
// create-user.dto.ts
import { IsString, IsInt, IsEmail } from 'class-validator';

export class CreateUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;

  @IsInt()
  @Min(18)
  age: number;
}
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: The Controller -->
                    <div class="col-md-6">
                        <div class="card h-100 border-danger">
                            <div class="card-header bg-danger text-white small">Step 2: Use in Controller</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
// user.controller.ts
@Post()
// The ValidationPipe reads the decorators
// in the DTO and validates the body automatically.
@UsePipes(new ValidationPipe())
create(@Body() createUserDto: CreateUserDto) {
  return 'User is valid!';
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Global Pipes Concept -->
                <div class="concept-box cb-red mt-4">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-globe fa-2x text-danger me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">Global Validation</h6>
                            <p class="small text-muted m-0">
                                Instead of adding <code>@UsePipes</code> to every controller, you can set it up once in
                                <code>main.ts</code>.
                            </p>
                            <code
                                class="small text-danger">app.useGlobalPipes(new ValidationPipe({ whitelist: true }));</code>
                            <br>
                            <small class="text-muted"><em>(Whitelist: true automatically strips properties that are not
                                    in the DTO. Security win!)</em></small>
                        </div>
                    </div>
                </div>

                <hr class="my-4">

                <!-- Custom Pipes -->
                <h6 class="fw-bold text-danger">8.4 Creating Custom Pipes</h6>
                <p class="small text-muted">
                    Sometimes built-in pipes aren't enough. You can create a custom pipe to perform specific validation
                    logic (e.g., verifying an ID format) or transformation (e.g., parsing a CSV string into an array).
                </p>

                <!-- The Code -->
                <div class="row g-0 border rounded overflow-hidden mb-3">
                    <div class="col-md-12 bg-white p-3">
                        <h6 class="small fw-bold text-dark mb-2">Example: Validation Pipe for ObjectId (MongoDB)</h6>
                        <pre class="m-0 border-0"><code class="language-typescript">
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { ObjectId } from 'mongodb';

@Injectable()
export class ValidateObjectIdPipe implements PipeTransform<string, string> {
  transform(value: string, metadata: ArgumentMetadata): string {
    // 1. Check if the value is valid
    if (!ObjectId.isValid(value)) {
      throw new BadRequestException('Invalid ObjectId');
    }
    
    // 2. Return the value (Transformation is optional)
    return value;
  }
}
                        </code></pre>
                    </div>
                </div>

                <!-- Applying Pipes -->
                <h6 class="fw-bold text-secondary mt-3">8.5 Applying Custom Pipes</h6>
                <p class="small text-muted">You use the <code>@UsePipes()</code> decorator or pass the class directly
                    into <code>@Body()</code> or <code>@Param()</code>.</p>

                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="card h-100 border-danger">
                            <div class="card-header bg-danger text-white small">Parameter Scoped (Best Practice)</div>
                            <div class="card-body p-2">
                                <p class="small mb-1">Validates only this specific argument.</p>
                                <pre class="m-0 border-0 p-2 rounded"><code class="language-typescript">
@Get(':id')
findOne(
  @Param('id', ValidateObjectIdPipe) id: string
) {
  return this.service.findOne(id);
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-secondary">
                            <div class="card-header bg-secondary text-white small">Method Scoped</div>
                            <div class="card-body p-2">
                                <p class="small mb-1">Validates all arguments for this method.</p>
                                <pre class="m-0 border-0 p-2 rounded"><code class="language-typescript">
@Post()
@UsePipes(ValidateObjectIdPipe) // Applies to Body & Params
create(@Body() dto: CreateDto) {
  // ...
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 9. Guards -->
        <section id="guards" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-shield-alt me-2 text-primary"></i>9. Guards (Authentication & Authorization)
                    <span class="migration-badge">Express: Middleware (Passport)</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="text-muted">
                    In Express, authentication is often handled by middleware (e.g.,
                    <code>passport.authenticate()</code>). The problem is that middleware is "dumb"—it doesn't know
                    <em>which</em> route handler is about to be executed.
                </p>
                <div class="alert alert-light border-start border-4 border-primary">
                    <strong>The NestJS Guard Advantage:</strong> Guards have access to the <code>ExecutionContext</code>
                    instance, so they know exactly what's going to be executed next. They return a <code>boolean</code>
                    indicating whether the request is allowed.
                </div>

                <!-- Logic Flow Diagram -->
                <h6 class="fw-bold text-secondary mt-4">9.1 The Authorization Flow</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Req[Request] --> MW[Middleware]
                        MW --> Guard{Guard}

                        Guard -- "True (Allowed)" --> Inter[Interceptor]
                        Inter --> Pipe[Pipe]
                        Pipe --> Ctrl[Controller]

                        Guard -- "False (Denied)" --> Err[403 Forbidden]

                        style Guard fill:#bbdefb,stroke:#1976d2
                        style Err fill:#ffcdd2,stroke:#d32f2f
                    </div>
                </div>

                <!-- Comparison: Express Middleware vs Nest Guard -->
                <h6 class="fw-bold text-secondary mt-4">9.2 Authorization Strategy Comparison</h6>
                <div class="row g-3">
                    <!-- Express -->
                    <div class="col-md-6">
                        <div class="card h-100 border-0 bg-light">
                            <div class="card-header bg-dark text-white small">Express (Middleware)</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-javascript">
// checkRole.js
module.exports = (role) => {
  return (req, res, next) => {
    if (req.user.role !== role) {
       return res.status(403).send();
    }
    next();
  }
}

// routes.js
app.get('/admin',
  authMiddleware,
  checkRole('admin'), // Manual wiring
  adminController
);
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- NestJS -->
                    <div class="col-md-6">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white small">NestJS (Guard + Metadata)</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
// admin.controller.ts
@Get()
@UseGuards(RolesGuard)
@Roles('admin') // Custom Decorator
findAll() {
  return [];
}

// roles.guard.ts
canActivate(context: ExecutionContext): boolean {
  const roles = this.reflector.get('roles', context.getHandler());
  // Logic to check user roles against metadata
  return true;
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 9.3 Passport Integration -->
                <h6 class="fw-bold text-secondary mt-4">9.3 Passport.js Integration</h6>
                <p class="small text-muted">
                    NestJS wraps Passport strategies into Guards, making migration seamless. You still define strategies
                    (JWT, Local), but you apply them declaratively.
                </p>

                <div class="row g-3">
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 bg-white shadow-sm">
                            <i class="fas fa-key fa-2x text-warning mb-2"></i>
                            <h6 class="fw-bold">AuthGuard('jwt')</h6>
                            <small class="text-muted">Standard guard provided by <code>@nestjs/passport</code>. Just
                                drop it on a controller.</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 bg-white shadow-sm">
                            <i class="fas fa-file-code fa-2x text-info mb-2"></i>
                            <h6 class="fw-bold">Strategy Class</h6>
                            <small class="text-muted">Instead of <code>passport.use()</code> in app.js, you create a
                                class extending <code>PassportStrategy</code>.</small>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 bg-white shadow-sm">
                            <i class="fas fa-user-tag fa-2x text-success mb-2"></i>
                            <h6 class="fw-bold">User Object</h6>
                            <small class="text-muted">Like Express, successful validation attaches the <code>user</code>
                                object to the <code>request</code>.</small>
                        </div>
                    </div>
                </div>

                <!-- Metadata Concept -->
                <div class="concept-box cb-blue mt-4">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-tags fa-2x text-primary me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">Reflector & Metadata</h6>
                            <p class="small text-muted m-0">
                                This is the superpower of NestJS Guards. You can attach custom metadata (like Roles,
                                Permissions, or "IsPublic") to routes using decorators, and the Guard can read that
                                metadata to make decisions dynamically.
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 10. Interceptors -->
        <section id="interceptors" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-random me-2 text-warning"></i>10. Interceptors (AOP & Response
                    Mapping)</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="text-muted">
                    Interceptors allow you to wrap the request/response stream. They can execute logic
                    <strong>before</strong> the route handler runs and transform the result <strong>after</strong> the
                    handler returns.
                </p>

                <div class="alert alert-light border-start border-4 border-warning">
                    <strong>Express Limitation:</strong> In Express, middleware executes sequentially. To modify a
                    response <em>after</em> the route handler sends it, you often have to monkey-patch
                    <code>res.send</code>.
                    <br>
                    <strong>NestJS Solution:</strong> Interceptors use <strong>RxJS Observables</strong> to tap into the
                    response stream cleanly.
                </div>

                <!-- The Sandwich Flow Diagram -->
                <h6 class="fw-bold text-secondary mt-4">10.1 The "Sandwich" Flow</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        sequenceDiagram
                        participant C as Client
                        participant I as Interceptor
                        participant H as Route Handler

                        C->>I: 1. Incoming Request
                        Note over I: Pre-Controller Logic<br>(e.g., Start Timer)
                        I->>H: 2. handle()
                        Note over H: Business Logic
                        H-->>I: 3. Returns Data (Observable)
                        Note over I: Post-Controller Logic<br>(e.g., Transform JSON / End Timer)
                        I-->>C: 4. Final Response
                    </div>
                </div>

                <!-- Code Example: Transform Interceptor -->
                <h6 class="fw-bold text-secondary mt-4">10.2 Example: Standardizing Responses</h6>
                <div class="row g-3">
                    <div class="col-md-5">
                        <div class="card h-100 bg-light border-0">
                            <div class="card-body">
                                <h6 class="fw-bold text-dark">The Goal</h6>
                                <p class="small">
                                    The controller returns <code>User[]</code>. <br>
                                    The client receives <code>{ data: User[] }</code>.
                                </p>
                                <hr>
                                <h6 class="fw-bold text-dark">RxJS Magic</h6>
                                <p class="small mb-0">
                                    We use the <code>.pipe()</code> method to manipulate the stream of data returning
                                    from the handler.
                                </p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-7">
                        <pre class="m-0 rounded"><code class="language-typescript">
import { CallHandler, ExecutionContext, NestInterceptor } from '@nestjs/common';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    // 1. Pre-controller logic here (optional)

    // 2. Handle request and transform response
    return next.handle().pipe(
      map(data => ({
        data: data,
        timestamp: new Date().toISOString()
      }))
    );
  }
}
                        </code></pre>
                    </div>
                </div>

                <!-- Common Use Cases Grid -->
                <h6 class="fw-bold text-secondary mt-4">10.3 Common Use Cases</h6>
                <div class="row g-3">
                    <div class="col-md-3">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <i class="fas fa-stopwatch fa-2x text-warning mb-2"></i><br>
                            <strong>Logging</strong><br>
                            <small class="text-muted">Calculate request duration.</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <i class="fas fa-file-code fa-2x text-info mb-2"></i><br>
                            <strong>Serialization</strong><br>
                            <small class="text-muted">Exclude passwords from response.</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <i class="fas fa-history fa-2x text-success mb-2"></i><br>
                            <strong>Caching</strong><br>
                            <small class="text-muted">Return cached data instead of calling handler.</small>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <i class="fas fa-hourglass-end fa-2x text-danger mb-2"></i><br>
                            <strong>Timeouts</strong><br>
                            <small class="text-muted">Cancel request if too long.</small>
                        </div>
                    </div>
                </div>

                <!-- Applying Interceptors -->
                <h6 class="fw-bold text-secondary mt-4">10.4 How to Apply Interceptors</h6>
                <p class="small text-muted">You can bind interceptors at three different levels depending on your scope.
                </p>

                <div class="row g-3 mb-4">
                    <!-- Method Scope -->
                    <div class="col-md-4">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white small">1. Method Scope</div>
                            <div class="card-body p-2">
                                <p class="small mb-2">Apply to a single route handler.</p>
                                <pre class="m-0 border-0 p-1"><code class="language-typescript">
@Get()
@UseInterceptors(LoggingInterceptor)
findAll() {}
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Controller Scope -->
                    <div class="col-md-4">
                        <div class="card h-100 border-success">
                            <div class="card-header bg-success text-white small">2. Controller Scope</div>
                            <div class="card-body p-2">
                                <p class="small mb-2">Apply to every route in a controller.</p>
                                <pre class="m-0 border-0 p-1"><code class="language-typescript">
@Controller('cats')
@UseInterceptors(LoggingInterceptor)
export class CatsController {}
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Global Scope -->
                    <div class="col-md-4">
                        <div class="card h-100 border-warning">
                            <div class="card-header bg-warning text-dark small">3. Global Scope</div>
                            <div class="card-body p-2">
                                <p class="small mb-2">Apply to the entire application.</p>
                                <pre class="m-0 border-0 p-1"><code class="language-typescript">
// main.ts
app.useGlobalInterceptors(
  new LoggingInterceptor()
);
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Global Injection Note -->
                <div class="alert alert-secondary d-flex align-items-center p-2 small">
                    <i class="fas fa-info-circle me-3"></i>
                    <div>
                        <strong>DI in Global Interceptors:</strong> If you use <code>app.useGlobalInterceptors()</code>
                        in <code>main.ts</code>, you cannot inject dependencies into the interceptor. To fix this,
                        register it as a provider in <code>app.module.ts</code> using the <code>APP_INTERCEPTOR</code>
                        token.
                    </div>
                </div>

                <!-- Exception Filters Note -->
                <div class="concept-box cb-red mt-4">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-exclamation-circle fa-2x text-danger me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">Bonus: Exception Filters</h6>
                            <p class="small text-muted m-0">
                                While Interceptors handle the <em>Happy Path</em> (Success), <strong>Exception
                                    Filters</strong> handle the <em>Sad Path</em> (Errors). They catch thrown exceptions
                                and format the error JSON sent to the client.
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 10.5 Error Handling -->
        <section id="errors" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-exclamation-triangle me-2 text-danger"></i>10.5 Error Handling (Exception Filters)
                    <span class="migration-badge">Express: (err, req, res, next)</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="text-muted">
                    In Express, you handle errors by passing them to <code>next(err)</code> and having a special
                    middleware at the end of your app. In NestJS, you simply <strong>throw</strong> an exception. The
                    framework catches it using an <strong>Exception Filter</strong> and formats the response
                    automatically.
                </p>

                <!-- Comparison -->
                <div class="row g-3 mb-4">
                    <!-- Express -->
                    <div class="col-md-6">
                        <div class="card h-100 bg-light border-0">
                            <div class="card-header bg-dark text-white small">Express (Centralized Middleware)</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-javascript">
// In Controller
if (!user) return next(new Error('Not Found'));

// In app.js (Order matters!)
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.message });
});
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- NestJS -->
                    <div class="col-md-6">
                        <div class="card h-100 border-danger">
                            <div class="card-header bg-danger text-white small">NestJS (Built-in Classes)</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
// In Controller / Service
if (!user) {
  // Nest auto-converts this to JSON 404
  throw new NotFoundException('User not found');
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Exception Flow Diagram -->
                <h6 class="fw-bold text-secondary">The Exception Flow</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        sequenceDiagram
                        participant C as Client
                        participant Con as Controller
                        participant F as Exception Filter

                        C->>Con: HTTP Request
                        Note over Con: Logic Fails
                        Con--xCon: Throw new HttpException()
                        Note right of Con: Processing Stops
                        Con->>F: Catch Exception
                        F-->>C: Formatted JSON Response
                    </div>
                </div>

                <!-- Built-in Exceptions -->
                <h6 class="fw-bold text-secondary mt-4">Built-in HTTP Exceptions</h6>
                <p class="small text-muted">NestJS provides classes for standard HTTP errors so you don't have to
                    memorize status codes.</p>
                <div class="row g-2 mb-4">
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>BadRequestException</code> (400)</div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>UnauthorizedException</code> (401)</div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>ForbiddenException</code> (403)</div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>NotFoundException</code> (404)</div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>ConflictException</code> (409)</div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-2 border rounded bg-light small"><code>InternalServerErrorException</code> (500)
                        </div>
                    </div>
                </div>

                <!-- Custom Filter Example -->
                <div class="concept-box cb-red">
                    <h6 class="fw-bold text-danger mb-2">Custom Exception Filters</h6>
                    <p class="small text-muted">
                        Want to override the default JSON error structure? Create a filter using the
                        <code>@Catch()</code> decorator. This allows you to log the error and send a custom response
                        format.
                    </p>
                    <pre class="m-0 border p-2 rounded"><code class="language-typescript">
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HttpErrorFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();

    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        message: exception.message,
      });
  }
}
                    </code></pre>
                    <div class="mt-2 text-end">
                        <span class="badge bg-secondary">Usage: @UseFilters(new HttpErrorFilter())</span>
                    </div>
                </div>

            </div>
        </section>

        <!-- 10.6 Consistent Responses -->
        <section id="responses" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-envelope-open-text me-2 text-info"></i>10.6 Consistent API Responses (The Envelope
                    Pattern)
                    <span class="migration-badge">Express: Helper Functions</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    In Express, developers often create utility functions like <code>sendSuccess(res, data)</code> or
                    <code>sendError(res, msg)</code> to ensure JSON consistency. In NestJS, we use
                    <strong>Aspect-Oriented Programming (AOP)</strong> to automatically wrap every single return value
                    and exception into a standard "Envelope" format.
                </p>

                <!-- The Goal Visualization -->
                <div class="row align-items-center mb-4">
                    <div class="col-md-5">
                        <div class="card bg-dark text-white border-0 shadow-sm">
                            <div class="card-header border-secondary p-2 small fw-bold text-center">
                                Standard Envelope Schema
                            </div>
                            <div class="card-body font-monospace p-3 small">
                                <pre class="m-0 text-white bg-transparent border-0 p-0">{
  <span class="text-info">"success"</span>: <span class="text-warning">true</span> | <span class="text-danger">false</span>,
  <span class="text-info">"statusCode"</span>: 200,
  <span class="text-info">"message"</span>: "Operation successful",
  <span class="text-info">"data"</span>: { ...payload... },
  <span class="text-info">"timestamp"</span>: "2023-10-27T..."
}</pre>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-7">
                        <div class="diagram-container m-0 p-2">
                            <div class="mermaid">
                                graph LR
                                Handler[Controller Return] -->|Raw Data| I[Interceptor]
                                I -->|"Wraps {success:true}"| Client

                                Error[Exception Thrown] -->|Raw Error| F[Filter]
                                F -->|"Wraps {success:false}"| Client

                                style I fill:#c8e6c9,stroke:#2e7d32
                                style F fill:#ffcdd2,stroke:#c62828
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Implementation Strategy -->
                <h6 class="fw-bold text-secondary">The Two-Pronged Approach</h6>

                <div class="row g-3">

                    <!-- 1. The Success Path -->
                    <div class="col-md-12">
                        <div class="concept-box cb-blue">
                            <div class="d-flex align-items-center mb-2">
                                <i class="fas fa-check-circle fa-2x text-primary me-3"></i>
                                <div>
                                    <h6 class="fw-bold text-dark m-0">1. Success: The Transform Interceptor</h6>
                                    <p class="small text-muted m-0">Automatically wraps any data returned from a
                                        controller.</p>
                                </div>
                            </div>

                            <pre class="m-0 border p-2 rounded"><code class="language-typescript">
// transform.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { map } from 'rxjs/operators';

export interface Response&lt;T&gt; {
  success: boolean;
  data: T;
}

@Injectable()
export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; {
  intercept(context: ExecutionContext, next: CallHandler) {
    return next.handle().pipe(
      map(data => ({
        success: true,
        statusCode: context.switchToHttp().getResponse().statusCode,
        message: 'Operation Successful',
        data: data
      }))
    );
  }
}
                            </code></pre>
                        </div>
                    </div>

                    <!-- 2. The Error Path -->
                    <div class="col-md-12">
                        <div class="concept-box cb-red">
                            <div class="d-flex align-items-center mb-2">
                                <i class="fas fa-times-circle fa-2x text-danger me-3"></i>
                                <div>
                                    <h6 class="fw-bold text-dark m-0">2. Error: The Exception Filter</h6>
                                    <p class="small text-muted m-0">Catches errors and formats them to match the
                                        envelope schema.</p>
                                </div>
                            </div>

                            <pre class="m-0 border p-2 rounded"><code class="language-typescript">
// http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const status = exception.getStatus();
    const errorResponse = exception.getResponse();

    response
      .status(status)
      .json({
        success: false,
        statusCode: status,
        // Handle both string messages and object error responses
        message: typeof errorResponse === 'string' ? errorResponse : (errorResponse as any).message,
        data: null
      });
  }
}
                            </code></pre>
                        </div>
                    </div>
                </div>

                <!-- Global Application -->
                <div class="alert alert-info mt-4 d-flex align-items-start">
                    <i class="fas fa-plug fa-2x me-3 mt-1 flex-shrink-0"></i>
                    <div class="w-100 overflow-hidden">
                        <strong>Applying Globally:</strong> In <code>main.ts</code>, register both to ensure every
                        single request adheres to the standard.
                        <pre class="m-0 mt-2 border rounded p-2 text-dark overflow-auto"><code class="language-typescript">
                app.useGlobalInterceptors(new TransformInterceptor());
                app.useGlobalFilters(new HttpExceptionFilter());
                                        </code></pre>
                    </div>
                </div>

            </div>
        </section>


        <!-- 11. Database -->
        <section id="database" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-database me-2 text-info"></i>11. Database Integration</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Introduction -->
                <p class="text-muted">
                    NestJS is database agnostic. It integrates easily with SQL (Postgres, MySQL) and NoSQL (MongoDB)
                    databases. The two most popular ORMs in the ecosystem are <strong>TypeORM</strong> and
                    <strong>Prisma</strong>.
                </p>

                <!-- Comparison Cards -->
                <div class="row g-4 mb-4">
                    <!-- TypeORM -->
                    <div class="col-md-6">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white text-center fw-bold">TypeORM</div>
                            <div class="card-body">
                                <ul class="small mb-0 list-group list-group-flush">
                                    <li class="list-group-item"><i
                                            class="fas fa-check text-success me-2"></i><strong>Mature:</strong> Long
                                        history, widely used.</li>
                                    <li class="list-group-item"><i
                                            class="fas fa-check text-success me-2"></i><strong>Pattern:</strong> Active
                                        Record & Data Mapper.</li>
                                    <li class="list-group-item"><i
                                            class="fas fa-code text-primary me-2"></i><strong>Decorators:</strong> Uses
                                        TS decorators heavily.</li>
                                    <li class="list-group-item"><code>@Entity(), @Column()</code></li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Prisma -->
                    <div class="col-md-6">
                        <div class="card h-100 border-dark">
                            <div class="card-header bg-dark text-white text-center fw-bold">Prisma</div>
                            <div class="card-body">
                                <ul class="small mb-0 list-group list-group-flush">
                                    <li class="list-group-item"><i
                                            class="fas fa-check text-success me-2"></i><strong>Modern:</strong> Next-gen
                                        ORM.</li>
                                    <li class="list-group-item"><i
                                            class="fas fa-check text-success me-2"></i><strong>Type-Safety:</strong>
                                        Auto-generated types from schema.</li>
                                    <li class="list-group-item"><i
                                            class="fas fa-file-code text-dark me-2"></i><strong>Schema:</strong> Uses
                                        <code>schema.prisma</code> file.
                                    </li>
                                    <li class="list-group-item">No decorators, pure JS/TS objects.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TypeORM Setup -->
                <h6 class="fw-bold text-secondary">11.1 Setting up TypeORM (The "Official" Way)</h6>
                <p class="small text-muted">NestJS provides a dedicated <code>@nestjs/typeorm</code> package.</p>

                <div class="row g-0 border rounded overflow-hidden mb-4">
                    <div class="col-md-12 bg-white p-3">
                        <pre class="m-0 border-0" style="font-size: 0.75rem;"><code class="language-typescript">
// app.module.ts
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './users/user.entity';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'db_user',
      password: 'db_password',
      database: 'test_db',
      entities: [User], // Register entities here
      synchronize: true, // Only for dev!
    }),
    UsersModule,
  ],
})
export class AppModule {}
                        </code></pre>
                    </div>
                </div>

                <!-- Repository Pattern Diagram -->
                <h6 class="fw-bold text-secondary mt-4">11.2 The Repository Pattern</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Ctrl[Controller] -->|Calls| Srv[Service]
                        Srv -->|Uses| Rep[Repository]
                        Rep -->|Queries| DB[(Database)]

                        style Rep fill:#bbdefb,stroke:#1976d2
                        style Srv fill:#fff9c4,stroke:#fbc02d
                    </div>
                </div>

                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="p-3 border rounded bg-white">
                            <h6 class="small fw-bold text-primary">Injecting Repositories</h6>
                            <pre class="m-0 p-0 border-0"><code class="language-typescript">
constructor(
  @InjectRepository(User)
  private usersRepository: Repository<User>,
) {}
                            </code></pre>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="p-3 border rounded bg-white">
                            <h6 class="small fw-bold text-success">Using Repositories</h6>
                            <pre class="m-0 p-0 border-0"><code class="language-typescript">
findAll(): Promise<User[]> {
  return this.usersRepository.find();
}
                            </code></pre>
                        </div>
                    </div>
                </div>

                <!-- Async Configuration -->
                <div class="concept-box cb-blue mt-4">
                    <h6 class="fw-bold text-primary mb-2">Configuration Best Practice</h6>
                    <p class="small text-muted mb-0">
                        Hardcoding credentials in <code>app.module.ts</code> is bad. Use <strong>ConfigService</strong>
                        (Environmental Variables) with <code>TypeOrmModule.forRootAsync()</code> to load database
                        secrets securely at runtime.
                    </p>
                </div>

            </div>
        </section>

        <!-- 12. Configuration -->
        <section id="config" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-sliders-h me-2 text-secondary"></i>12. Configuration (Env
                    Variables)</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    Hardcoding database passwords or API keys is a major security risk. NestJS provides a dedicated
                    <strong>ConfigModule</strong> (based on <code>dotenv</code>) to manage environment variables in a
                    type-safe and structured way.
                </p>
                <div class="alert alert-light border-start border-4 border-secondary">
                    <strong>Express Approach:</strong> Manually requiring <code>dotenv</code> at the top of
                    <code>index.js</code> and accessing <code>process.env</code> directly throughout the codebase.<br>
                    <strong>NestJS Approach:</strong> Injecting a <strong>ConfigService</strong> to access variables,
                    enabling mocking for tests and runtime validation.
                </div>

                <!-- Installation -->
                <div class="card bg-dark text-white border-0 shadow-sm mb-4">
                    <div class="card-body font-monospace p-3">
                        <span class="text-success">$</span> npm i --save @nestjs/config
                    </div>
                </div>

                <!-- Setup Flow Diagram -->
                <h6 class="fw-bold text-secondary">12.1 The Configuration Flow</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Env[.env File] -->|Loads| Mod[ConfigModule]
                        Mod -->|Validates| Joi{Joi Schema}
                        Joi --x|Fail| Error[Startup Error]
                        Joi -->|Success| Srv[ConfigService]
                        Srv -->|Injects| App[App Components]

                        style Env fill:#fff9c4,stroke:#fbc02d
                        style Srv fill:#bbdefb,stroke:#2196f3
                        style Error fill:#ffcdd2,stroke:#c62828
                    </div>
                </div>

                <!-- Implementation Guide -->
                <h6 class="fw-bold text-secondary mt-4">12.2 Implementation Steps</h6>

                <div class="row g-3">
                    <!-- Step 1: Setup -->
                    <div class="col-md-12">
                        <div class="card h-100 border-secondary">
                            <div class="card-header bg-secondary text-white small">1. Setup in AppModule</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // Makes ConfigModule available everywhere
      envFilePath: '.env.development',
    }),
  ],
})
export class AppModule {}
                                </code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: Usage -->
                    <div class="col-md-12">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white small">2. Usage in Service</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
import { ConfigService } from '@nestjs/config';

@Injectable()
export class AppService {
  constructor(private configService: ConfigService) {}

  getDatabaseHost() {
    // Type-safe getter usually returns string | undefined
    // You can use Generics to specify return type
    return this.configService.get<string>('DATABASE_HOST');
  }
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Validation Section -->
                <div class="concept-box cb-red mt-4">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-check-circle fa-2x text-danger me-3"></i>
                        <h6 class="fw-bold text-dark m-0">Schema Validation (Joi)</h6>
                    </div>
                    <p class="small text-muted">
                        Avoid runtime errors by ensuring required variables exist <strong>before</strong> the app
                        starts. NestJS integrates with <code>joi</code> to validate the <code>.env</code> file on
                        startup.
                    </p>
                    <pre class="rounded border"><code class="language-typescript">
// npm i joi
import * as Joi from 'joi';

ConfigModule.forRoot({
  validationSchema: Joi.object({
    NODE_ENV: Joi.string()
      .valid('development', 'production')
      .default('development'),
    PORT: Joi.number().default(3000),
    DATABASE_URL: Joi.string().required(), // App fails if missing
  }),
})
                    </code></pre>
                </div>

                <!-- Pro Tip -->
                <div class="row mt-3">
                    <div class="col-12">
                        <div class="p-3 border rounded bg-light">
                            <h6 class="small fw-bold text-primary"><i class="fas fa-lightbulb me-2"></i>Why use
                                ConfigService instead of process.env?</h6>
                            <ul class="small text-muted mb-0 ps-3">
                                <li><strong>Mocking:</strong> In unit tests, you can easily mock
                                    <code>ConfigService</code> to return fake values. You cannot easily mock the global
                                    <code>process.env</code>.
                                </li>
                                <li><strong>Type Safety:</strong> Generics allow you to specify what type of data you
                                    expect.</li>
                                <li><strong>Centralization:</strong> You can define custom getters or computed
                                    configuration logic in one place.</li>
                            </ul>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 13. Testing -->
        <section id="testing" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-vial me-2 text-success"></i>13. Testing (Jest & Supertest)</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    In the Express ecosystem, setting up a test harness (Jest/Mocha, Chai, Sinon, Supertest) takes time
                    and configuration. In <strong>NestJS</strong>, Jest is pre-configured out of the box. Every time you
                    generate a component via CLI, a corresponding <code>.spec.ts</code> file is created.
                </p>

                <!-- Comparison Cards -->
                <div class="row g-3 mb-4">
                    <div class="col-md-6">
                        <div class="card h-100 border-0 bg-light">
                            <div class="card-body">
                                <h6 class="fw-bold text-dark">Unit Testing</h6>
                                <p class="small mb-0">Testing individual classes (Services, Controllers) in isolation by
                                    <strong>mocking</strong> their dependencies.
                                </p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-0 bg-light">
                            <div class="card-body">
                                <h6 class="fw-bold text-dark">E2E Testing</h6>
                                <p class="small mb-0">Testing the entire application flow (HTTP Request -> Controller ->
                                    Service -> DB) using <strong>Supertest</strong>.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- The Testing Module Diagram -->
                <h6 class="fw-bold text-secondary">13.1 The Testing Module Architecture</h6>
                <p class="small text-muted">NestJS provides the <code>Test</code> class to create an isolated module
                    environment, mimicking the behavior of the main application runtime but allowing you to swap real
                    providers with mocks.</p>

                <div class="diagram-container">
                    <div class="mermaid">
                        graph TD
                        subgraph Test_Environment [Test Environment]
                        TR[Test Runner - Jest]
                        TM[Test.createTestingModule]

                        subgraph Mocked_Module [Mocked Module]
                        Ctrl[UsersController]
                        MockSrv[Mock UsersService]
                        end
                        end

                        Real[Real UsersService]

                        TR --> TM
                        TM --> Ctrl
                        TM --x|Ignores| Real
                        TM --> MockSrv

                        style MockSrv fill:#a5d6a7,stroke:#2e7d32
                        style Real fill:#ef9a9a,stroke:#c62828,stroke-dasharray: 5 5
                    </div>
                </div>

                <!-- Unit Testing Example -->
                <h6 class="fw-bold text-secondary mt-4">13.2 Unit Testing Example</h6>
                <p class="small">Notice how we compile a module and override the provider.</p>

                <div class="row g-0 border rounded overflow-hidden mb-4">
                    <div class="col-md-12 bg-white p-3">
                        <pre class="m-0 border-0"><code class="language-typescript">
import { Test, TestingModule } from '@nestjs/testing';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

describe('UsersController', () => {
  let controller: UsersController;
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [
        {
          provide: UsersService,
          // MOCKING THE SERVICE
          useValue: {
            findAll: jest.fn().mockResolvedValue(['User1', 'User2']),
          },
        },
      ],
    }).compile();

    controller = module.get<UsersController>(UsersController);
    service = module.get<UsersService>(UsersService);
  });

  it('should return an array of users', async () => {
    expect(await controller.findAll()).toEqual(['User1', 'User2']);
    expect(service.findAll).toHaveBeenCalled();
  });
});
                        </code></pre>
                    </div>
                </div>

                <!-- E2E Testing -->
                <div class="concept-box cb-blue">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-network-wired fa-2x text-primary me-3"></i>
                        <h6 class="fw-bold text-dark m-0">End-to-End (E2E) Testing</h6>
                    </div>
                    <p class="small text-muted">
                        E2E tests are located in the <code>/test</code> directory. They spin up the NestJS application
                        instance and hit the endpoints using HTTP.
                    </p>
                    <pre class="m-0 border p-2 rounded"><code class="language-typescript">
// app.e2e-spec.ts
request(app.getHttpServer())
  .get('/users')
  .expect(200)
  .expect({
    data: ['User1', 'User2']
  });
                    </code></pre>
                </div>

                <!-- Key Benefits -->
                <div class="row mt-3">
                    <div class="col-12">
                        <div class="alert alert-success d-flex align-items-center mb-0">
                            <i class="fas fa-check-circle fa-lg me-3"></i>
                            <div>
                                <strong>Why this is better than Express:</strong> In Express, dependency injection is
                                manual. If your controller imports a database model directly, you cannot unit test the
                                controller without hitting the database. In NestJS, DI makes mocking trivial.
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 14. Microservices -->
        <section id="microservices" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold"><i class="fas fa-network-wired me-2 text-dark"></i>14. Microservices (Scaling
                    Out)</h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    Express.js is often used for microservices, but communication between services usually requires
                    manual HTTP requests (Axios/Fetch) or setting up message brokers from scratch. <strong>NestJS
                        supports Microservices natively</strong> via the <code>@nestjs/microservices</code> package,
                    abstracting the transport layer entirely.
                </p>

                <!-- Monolith vs Microservice Diagram -->
                <h6 class="fw-bold text-secondary">14.1 Architecture Shift</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        subgraph Monolith
                        C1[Client] --> API[API Gateway / App]
                        API --> Logic
                        API --> DB[(Database)]
                        end

                        subgraph Microservices
                        C2[Client] --> Gate[API Gateway]
                        Gate -.->|TCP/Redis| Auth[Auth Service]
                        Gate -.->|RabbitMQ| Order[Order Service]
                        Gate -.->|gRPC| Pay[Payment Service]

                        Auth --> DB1[(Auth DB)]
                        Order --> DB2[(Order DB)]
                        end

                        style Gate fill:#E0234E,color:white,stroke:#333
                        style Auth fill:#ffecb3,stroke:#ffb300
                        style Order fill:#b3e5fc,stroke:#03a9f4
                        style Pay fill:#c8e6c9,stroke:#4caf50
                    </div>
                </div>

                <!-- Transport Layers -->
                <h6 class="fw-bold text-secondary mt-4">14.2 Supported Transporters</h6>
                <p class="small text-muted">You can switch the transport strategy by changing <strong>one line of
                        configuration</strong>.</p>

                <div class="row g-2 mb-4">
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">TCP (Default)</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">Redis (Pub/Sub)</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">RabbitMQ</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">Kafka</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">gRPC</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">MQTT</div>
                    </div>
                    <div class="col-md-3">
                        <div class="p-2 border rounded bg-light text-center small fw-bold">NATS</div>
                    </div>
                </div>

                <!-- Pattern Comparison -->
                <div class="row g-0 border rounded overflow-hidden mb-4">
                    <!-- Request-Response -->
                    <div class="col-md-6 border-end p-3">
                        <h6 class="text-primary fw-bold small"><i class="fas fa-exchange-alt me-2"></i>Request-Response
                        </h6>
                        <p class="small text-muted">Ideal for when you need an answer (e.g., Auth check).</p>
                        <pre class="m-0 border-0"><code class="language-typescript">
// Gateway (Client)
this.client.send({ cmd: 'get_user' }, id);

// Microservice (Server)
@MessagePattern({ cmd: 'get_user' })
getUser(id: number) {
  return this.users.find(id);
}
                        </code></pre>
                    </div>

                    <!-- Event-Based -->
                    <div class="col-md-6 bg-white p-3">
                        <h6 class="text-warning fw-bold small"><i class="fas fa-bullhorn me-2"></i>Event-Based</h6>
                        <p class="small text-muted">Fire and forget (e.g., Sending email after order).</p>
                        <pre class="m-0 border-0"><code class="language-typescript">
// Gateway (Client)
this.client.emit('order_created', order);

// Microservice (Server)
@EventPattern('order_created')
handleOrderCreated(order: Order) {
  this.emailService.sendReceipt(order);
}
                        </code></pre>
                    </div>
                </div>

                <!-- Client Proxy -->
                <div class="concept-box cb-red mt-3">
                    <h6 class="fw-bold text-dark">ClientProxy & Injection</h6>
                    <p class="small text-muted mb-0">
                        In NestJS, a microservice client is just another <strong>Provider</strong>. You configure it in
                        your module and inject it into your controller using <code>@Inject('SERVICE_NAME')</code>. This
                        makes testing easy because you can mock the microservice client!
                    </p>
                </div>

                <!-- Hybrid Application -->
                <div class="alert alert-info mt-3 d-flex align-items-center">
                    <i class="fas fa-info-circle fa-2x me-3"></i>
                    <div>
                        <strong>Hybrid Apps:</strong> A NestJS app can be both an HTTP server (handling REST/GraphQL)
                        <em>and</em> a Microservice (listening for events) at the same time. This is perfect for
                        Monolith-to-Microservice migration strategies.
                    </div>
                </div>

            </div>
        </section>

        <!-- 15. Swagger -->
        <section id="swagger" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-book me-2 text-primary"></i>15. API Documentation (Swagger)
                    <span class="migration-badge">Express: swagger-jsdoc (Manual)</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <p class="text-muted">
                    In Express, you often write YAML/JSON files manually or use JSDoc comments to generate API docs. In
                    <strong>NestJS</strong>, you use decorators. The framework scans your code and generates the OpenAPI
                    spec automatically.
                </p>

                <!-- Workflow Diagram -->
                <h6 class="fw-bold text-secondary">15.1 The "Code First" Workflow</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Code[Controller & DTO] -->|Scans Decorators| Compiler
                        Compiler -->|Generates| JSON[OpenAPI Spec]
                        JSON -->|Renders| UI[Swagger UI Page]

                        style Code fill:#e3f2fd,stroke:#2196f3
                        style UI fill:#c8e6c9,stroke:#388e3c
                    </div>
                </div>

                <!-- Implementation -->
                <div class="row g-4 mt-2">
                    <div class="col-md-6">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white small">1. The DTO</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
export class CreateCatDto {
  @ApiProperty({ 
    example: 'Kitty', 
    description: 'The name of the Cat' 
  })
  @IsString()
  name: string;

  @ApiProperty({ example: 5 })
  @IsInt()
  age: number;
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-success">
                            <div class="card-header bg-success text-white small">2. The Controller</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
@Post()
@ApiOperation({ summary: 'Create cat' })
@ApiResponse({ status: 403, description: 'Forbidden.' })
async create(@Body() createCatDto: CreateCatDto) {
  return 'Cat created';
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info mt-4">
                    <strong>Result:</strong> When you run the app, you get a fully interactive UI at <code>/api</code>
                    without writing a single line of YAML.
                </div>
            </div>
        </section>

        <!-- 16. Queues -->
        <section id="queues" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-layer-group me-2 text-warning"></i>16. Task Queues (Bull/Redis)
                    <span class="migration-badge">Express: Bull (Manual Setup)</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <p class="text-muted">
                    Offload heavy tasks (sending emails, video processing) to the background. NestJS provides the
                    <code>@nestjs/bull</code> package, which abstracts Redis queues into <strong>Modules</strong> and
                    <strong>Processors</strong>.
                </p>

                <!-- Architecture Diagram -->
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        User -->|HTTP Request| API[Controller]
                        API -->|1. Add Job| Q[(Redis Queue)]

                        subgraph Worker Service
                        Q -->|2. Pick Job| Proc[Processor Class]
                        Proc -->|3. Execute| Logic[Business Logic]
                        Logic -->|4. Event| Complete[OnCompleted]
                        end

                        style Q fill:#ffcc80,stroke:#f57c00
                        style Proc fill:#fff9c4,stroke:#fbc02d
                    </div>
                </div>

                <!-- Code Example -->
                <h6 class="fw-bold text-secondary mt-4">16.1 Producer vs Consumer</h6>
                <div class="row g-0 border rounded overflow-hidden">
                    <div class="col-md-6 border-end bg-white p-3">
                        <h6 class="text-primary fw-bold small">Producer (Service)</h6>
                        <pre class="m-0 border-0"><code class="language-typescript">
constructor(
  @InjectQueue('audio') private audioQueue: Queue
) {}

async transcode() {
  await this.audioQueue.add('transcode', {
    file: 'audio.mp3',
  });
}
                        </code></pre>
                    </div>
                    <div class="col-md-6 bg-white p-3">
                        <h6 class="text-warning fw-bold small">Consumer (Processor)</h6>
                        <pre class="m-0 border-0"><code class="language-typescript">
@Processor('audio')
export class AudioProcessor {
  
  @Process('transcode')
  async handleTranscode(job: Job) {
    console.log('Processing...', job.data);
    // Heavy logic here
  }
}
                        </code></pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- 17. Custom Decorators -->
        <section id="decorators" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-magic me-2 text-purple"></i>17. Custom Decorators
                    <span class="migration-badge">Express: N/A</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <p class="text-muted">
                    Express relies heavily on the `req` object. NestJS encourages you to create your own decorators to
                    extract data, making your controllers cleaner and platform-agnostic.
                </p>

                <!-- Comparison -->
                <div class="row align-items-center mb-4">
                    <div class="col-md-5">
                        <div class="card bg-light border-0">
                            <div class="card-body">
                                <h6 class="text-muted small mb-1">Express / Standard Nest</h6>
                                <code class="text-dark">findOne(@Req() req)</code>
                                <p class="small text-muted mt-2 mb-0">Ties you to Express. Harder to test (must mock
                                    entire Request object).</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-2 text-center">
                        <i class="fas fa-arrow-right text-muted"></i>
                    </div>
                    <div class="col-md-5">
                        <div class="card border-primary">
                            <div class="card-body">
                                <h6 class="text-primary small mb-1">Custom Decorator</h6>
                                <code class="text-primary">findOne(@User() user)</code>
                                <p class="small text-muted mt-2 mb-0">Clean. Explicit. Easy to test (just pass a user
                                    object).</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Implementation -->
                <h6 class="fw-bold text-secondary">17.1 How to create one</h6>
                <pre class="rounded"><code class="language-typescript">
// user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const User = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user; // Extracted from JWT Guard
  },
);

// controller.ts
@Get()
// Now we get the user directly!
getProfile(@User() user: UserEntity) {
  console.log(user); 
}
                </code></pre>
            </div>
        </section>

        <!-- 18. API Versioning -->
        <section id="versioning" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-code-branch me-2 text-info"></i>18. API Versioning
                    <span class="migration-badge">Express: Manual Router Splits</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <!-- Intro -->
                <p class="text-muted">
                    APIs evolve. In Express, you typically handle versioning by manually creating folders like
                    <code>routes/v1/</code> and <code>routes/v2/</code> and mounting them separately.
                    <strong>NestJS</strong> provides a built-in, global versioning mechanism that handles this routing
                    logic via decorators.
                </p>

                <!-- Strategies Diagram -->
                <h6 class="fw-bold text-secondary">18.1 Versioning Strategies</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph TD
                        Client[Client Request] --> Strategy{Versioning Strategy}

                        Strategy -->|URI| URI["/v1/users<br>(Most Common)"]
                        Strategy -->|Header| Header["X-API-VERSION: 1"]
                        Strategy -->|Media Type| Media["Accept: application/vnd.v1+json"]

                        URI --> Router
                        Header --> Router
                        Media --> Router

                        Router -->|Finds| V1[V1 Controller]
                        Router -->|Finds| V2[V2 Controller]

                        style URI fill:#b3e5fc,stroke:#0288d1
                        style Header fill:#ffecb3,stroke:#ffb300
                        style Media fill:#e1bee7,stroke:#8e24aa
                    </div>
                </div>

                <!-- Setup Code -->
                <h6 class="fw-bold text-secondary mt-4">18.2 Enabling Versioning (main.ts)</h6>
                <div class="row g-0 border rounded overflow-hidden mb-4">
                    <div class="col-md-12 bg-white p-3">
                        <pre class="m-0 border-0"><code class="language-typescript">
import { VersioningType } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // 1. Enable Global Versioning
  app.enableVersioning({
    type: VersioningType.URI, // or HEADER, MEDIA_TYPE
    defaultVersion: '1', // Optional default
    // If using HEADER:
    // header: 'Custom-Header',
  });

  await app.listen(3000);
}
                        </code></pre>
                    </div>
                </div>

                <!-- Controller Implementation -->
                <h6 class="fw-bold text-secondary">18.3 Usage in Controllers</h6>
                <p class="small text-muted">You can version an entire controller or a specific route handler.</p>

                <div class="row g-3">
                    <div class="col-md-6">
                        <div class="card h-100 border-primary">
                            <div class="card-header bg-primary text-white small">V1 Controller</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
@Controller({
  path: 'users',
  version: '1', // Routes to /v1/users
})
export class UsersControllerV1 {
  @Get()
  findAll() {
    return 'This is Version 1';
  }
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card h-100 border-success">
                            <div class="card-header bg-success text-white small">V2 Controller (New Feature)</div>
                            <div class="card-body p-0">
                                <pre class="m-0 border-0"><code class="language-typescript">
@Controller({
  path: 'users',
  version: '2', // Routes to /v2/users
})
export class UsersControllerV2 {
  @Get()
  findAll() {
    return 'This is Version 2 (Improved)';
  }
}
                                </code></pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Version Neutral Concept -->
                <div class="concept-box cb-blue mt-4">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-infinity fa-2x text-primary me-3"></i>
                        <h6 class="fw-bold text-dark m-0">Version Neutral</h6>
                    </div>
                    <p class="small text-muted mb-0">
                        Some routes (like Health Checks) shouldn't change. You can mark them as
                        <code>VERSION_NEUTRAL</code> to make them accessible regardless of the requested version (e.g.,
                        just <code>/health</code>).
                    </p>
                    <pre
                        class="m-0 mt-2 border p-2 rounded"><code class="language-typescript">@Controller({ version: VERSION_NEUTRAL })</code></pre>
                </div>

            </div>
        </section>

        <!-- 19. Project Structure -->
        <section id="structure" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-folder-tree me-2 text-warning"></i>19. Project Structure (Enterprise Grade)
                    <span class="migration-badge">Express: Flexible/Unopinionated</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <p class="text-muted">
                    While Express allows you to put files anywhere, NestJS encourages a <strong>Modular</strong>
                    structure. For enterprise apps, we separate <strong>Features</strong> (Business Logic) from
                    <strong>Core</strong> (System Configuration) and <strong>Shared</strong> (Reusable Utils).
                </p>

                <div class="row g-4">

                    <!-- Visual Tree Structure -->
                    <div class="col-lg-6">
                        <div class="card h-100 shadow-sm border-0">
                            <div class="card-header bg-dark text-white small fw-bold">
                                <i class="fas fa-project-diagram me-2"></i>Directory Map
                            </div>
                            <div class="card-body p-3 font-monospace"
                                style="background-color: #2b2b2b; color: #dcdcdc; font-size: 0.85rem;">
                                <!-- Root -->
                                <div class="mb-1"><i class="fas fa-folder-open text-warning me-2"></i>src/</div>

                                <!-- Main Files -->
                                <div class="ms-3 mb-1"><i class="fab fa-js text-primary me-2"></i>main.ts <span
                                        class="text-muted ms-2">// Entry point</span></div>
                                <div class="ms-3 mb-1"><i class="fas fa-cube text-danger me-2"></i>app.module.ts <span
                                        class="text-muted ms-2">// Root Module</span></div>

                                <!-- Common Folder -->
                                <div class="ms-3 mt-2"><i class="fas fa-folder text-warning me-2"></i>common/ <span
                                        class="text-secondary ms-2">// Global Utils</span></div>
                                <div class="ms-4"><i class="fas fa-folder text-warning me-2"></i>decorators/</div>
                                <div class="ms-4"><i class="fas fa-folder text-warning me-2"></i>filters/</div>
                                <div class="ms-4"><i class="fas fa-folder text-warning me-2"></i>guards/</div>
                                <div class="ms-4"><i class="fas fa-folder text-warning me-2"></i>middleware/</div>

                                <!-- Config Folder -->
                                <div class="ms-3 mt-2"><i class="fas fa-folder text-warning me-2"></i>config/ <span
                                        class="text-secondary ms-2">// Env Validations</span></div>

                                <!-- Features (Users) -->
                                <div class="ms-3 mt-2"><i class="fas fa-folder text-info me-2"></i>modules/ <span
                                        class="text-secondary ms-2">// Feature Modules</span></div>

                                <!-- User Module Detail -->
                                <div class="ms-4"><i class="fas fa-folder-open text-info me-2"></i>users/</div>
                                <div class="ms-5"><i class="fas fa-folder text-success me-2"></i>dto/ <span
                                        class="text-secondary ms-2">// Validation Classes</span></div>
                                <div class="ms-5"><i class="fas fa-folder text-success me-2"></i>entities/ <span
                                        class="text-secondary ms-2">// DB Models</span></div>
                                <div class="ms-5"><i class="fas fa-route text-primary me-2"></i>users.controller.ts
                                </div>
                                <div class="ms-5"><i class="fas fa-cogs text-warning me-2"></i>users.service.ts</div>
                                <div class="ms-5"><i class="fas fa-cube text-danger me-2"></i>users.module.ts</div>
                                <div class="ms-5"><i class="fas fa-vial text-success me-2"></i>users.spec.ts</div>

                                <!-- Auth Module -->
                                <div class="ms-4 mt-1"><i class="fas fa-folder text-info me-2"></i>auth/</div>
                            </div>
                        </div>
                    </div>

                    <!-- Explanations -->
                    <div class="col-lg-6">
                        <div class="accordion" id="structureAccordion">

                            <!-- 1. Modules Directory -->
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button fw-bold text-info" type="button"
                                        data-bs-toggle="collapse" data-bs-target="#dir-modules">
                                        <i class="fas fa-cubes me-2"></i> src/modules/
                                    </button>
                                </h2>
                                <div id="dir-modules" class="accordion-collapse collapse show"
                                    data-bs-parent="#structureAccordion">
                                    <div class="accordion-body small">
                                        This is where your business logic lives. Each feature (Users, Orders, Auth) gets
                                        its own folder containing:
                                        <ul>
                                            <li><strong>Module:</strong> The glue file.</li>
                                            <li><strong>Controller:</strong> Routes.</li>
                                            <li><strong>Service:</strong> Business logic.</li>
                                            <li><strong>DTOs:</strong> Input validation schemas.</li>
                                            <li><strong>Entities:</strong> Database table definitions.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <!-- 2. Common Directory -->
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed fw-bold text-success" type="button"
                                        data-bs-toggle="collapse" data-bs-target="#dir-common">
                                        <i class="fas fa-toolbox me-2"></i> src/common/
                                    </button>
                                </h2>
                                <div id="dir-common" class="accordion-collapse collapse"
                                    data-bs-parent="#structureAccordion">
                                    <div class="accordion-body small">
                                        Contains logic that is <strong>reusable across the entire application</strong>,
                                        not specific to one feature.
                                        <ul>
                                            <li><strong>Decorators:</strong> <code>@User()</code>,
                                                <code>@Roles()</code>.
                                            </li>
                                            <li><strong>Guards:</strong> API Key checks, JWT logic.</li>
                                            <li><strong>Interceptors:</strong> Response formatting.</li>
                                            <li><strong>Filters:</strong> Global error handling.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <!-- 3. Config Directory -->
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed fw-bold text-dark" type="button"
                                        data-bs-toggle="collapse" data-bs-target="#dir-config">
                                        <i class="fas fa-sliders-h me-2"></i> src/config/
                                    </button>
                                </h2>
                                <div id="dir-config" class="accordion-collapse collapse"
                                    data-bs-parent="#structureAccordion">
                                    <div class="accordion-body small">
                                        Centralized configuration setup.
                                        <ul>
                                            <li>Database configurations (TypeORM/Prisma options).</li>
                                            <li>Environment variable validation schemas (Joi).</li>
                                            <li>Third-party API keys setup.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>

                <!-- Pro Tip: Barrel Files -->
                <div class="concept-box cb-blue mt-4">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-file-archive fa-2x text-primary me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">Pro Tip: Barrel Files (index.ts)</h6>
                            <p class="small text-muted m-0">
                                Create an <code>index.ts</code> in your folders to export everything. This cleans up
                                your imports significantly.
                            </p>
                        </div>
                    </div>
                    <div class="row g-0 border rounded mt-2">
                        <div class="col-6 bg-light p-2 border-end">
                            <small class="text-danger fw-bold">Messy Import</small><br>
                            <code
                                class="small text-muted">import { User } from '../modules/users/entities/user.entity';</code>
                        </div>
                        <div class="col-6 bg-white p-2">
                            <small class="text-success fw-bold">Clean Import</small><br>
                            <code class="small text-dark">import { User } from '@modules/users';</code>
                        </div>
                    </div>
                </div>

            </div>
        </section>

        <!-- 20. WebSockets -->
        <section id="websockets" class="topic-card">
            <div class="topic-header" onclick="toggleContent(this)">
                <h5 class="m-0 fw-bold">
                    <i class="fas fa-satellite-dish me-2 text-danger"></i>20. Real-Time Communication (WebSockets)
                    <span class="migration-badge">Express: io.on('connection')</span>
                </h5>
                <i class="fas fa-chevron-down text-muted"></i>
            </div>
            <div class="content-body">

                <p class="text-muted">
                    In Express, you typically attach <code>socket.io</code> to your HTTP server instance and write huge
                    callback chains inside <code>io.on('connection')</code>. In <strong>NestJS</strong>, we use
                    <strong>Gateways</strong>. These look exactly like Controllers, but for WebSocket events.
                </p>

                <!-- Architecture Diagram -->
                <h6 class="fw-bold text-secondary">20.1 Gateway Architecture</h6>
                <div class="diagram-container">
                    <div class="mermaid">
                        graph LR
                        Client((Client)) <-->|WS Connection| Gateway[Events Gateway]

                            subgraph NestJS_App
                            Gateway -->|@SubscribeMessage| Handler[Event Handler]
                            Handler -->|Injects| Srv[Auth Service]
                            Handler -->|Returns| Client
                            end

                            style Gateway fill:#ffcdd2,stroke:#b71c1c
                            style Handler fill:#e1bee7,stroke:#4a148c
                    </div>
                </div>

                <!-- Comparison -->
                <h6 class="fw-bold text-secondary mt-4">20.2 The Implementation Shift</h6>
                <div class="row g-0 border rounded overflow-hidden mb-4">

                    <!-- Express Code -->
                    <div class="col-md-6 border-end bg-light p-3">
                        <div class="d-flex align-items-center mb-2">
                            <i class="fab fa-node-js fa-lg me-2 text-muted"></i>
                            <h6 class="fw-bold m-0 small">Express (Callback Hell)</h6>
                        </div>
                        <pre class="m-0 border-0"><code class="language-javascript">
const io = require('socket.io')(server);

io.on('connection', (socket) => {
  console.log('User connected');

  socket.on('chat_message', (msg) => {
    // Logic inside the callback
    // Hard to inject database services here
    io.emit('chat_message', msg);
  });
});
                        </code></pre>
                    </div>

                    <!-- NestJS Code -->
                    <div class="col-md-6 bg-white p-3">
                        <div class="d-flex align-items-center mb-2">
                            <i class="fas fa-satellite-dish fa-lg me-2 text-danger"></i>
                            <h6 class="fw-bold m-0 small text-danger">NestJS (Declarative)</h6>
                        </div>
                        <pre class="m-0 border-0"><code class="language-typescript">
@WebSocketGateway({ cors: true })
export class ChatGateway {
  
  @WebSocketServer()
  server: Server;

  @SubscribeMessage('chat_message')
  handleMessage(@MessageBody() data: string): void {
    // Logic is separated
    // Easy to inject services via Constructor
    this.server.emit('chat_message', data);
  }
}
                        </code></pre>
                    </div>
                </div>

                <!-- Decorator Cheat Sheet -->
                <h6 class="fw-bold text-secondary">20.3 WebSocket Decorators</h6>
                <div class="row g-3">
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <code class="text-danger fw-bold">@WebSocketGateway()</code>
                            <p class="small text-muted mt-2 mb-0">Marks a class as a Gateway (Controller for Sockets).
                                Handles Port and CORS.</p>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <code class="text-primary fw-bold">@SubscribeMessage()</code>
                            <p class="small text-muted mt-2 mb-0">Listens for a specific event name (e.g., 'join_room').
                                Replaces <code>socket.on()</code>.</p>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="p-3 border rounded text-center h-100 shadow-sm">
                            <code class="text-success fw-bold">@MessageBody()</code>
                            <p class="small text-muted mt-2 mb-0">Extracts the payload sent by the client. Clean and
                                type-safe.</p>
                        </div>
                    </div>
                </div>

                <!-- Adapters Concept -->
                <div class="concept-box cb-red mt-4">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-plug fa-2x text-danger me-3"></i>
                        <div>
                            <h6 class="fw-bold text-dark m-0">The Adapter Pattern</h6>
                            <p class="small text-muted m-0">
                                NestJS is platform-agnostic. By default, it uses <strong>Socket.io</strong>, but you can
                                switch to <strong>Ws</strong> (native WebSockets) just by changing the adapter in
                                <code>main.ts</code>, without rewriting your gateway logic.
                            </p>
                        </div>
                    </div>
                </div>

            </div>
        </section>

    </main>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>

    <!-- Mermaid & Toggle Logic -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false });

        window.toggleContent = async function (header) {
            const body = header.nextElementSibling;
            const icon = header.querySelector('.fa-chevron-down, .fa-chevron-up');

            if (body.style.display === "block") {
                body.style.display = "none";
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            } else {
                body.style.display = "block";
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');

                // Initialize Mermaid inside this block if present
                const diagrams = body.querySelectorAll('.mermaid');
                if (diagrams.length > 0) {
                    await mermaid.run({ nodes: diagrams });
                }
            }
        }

        window.toggleSidebar = function () {
            document.getElementById('sidebar').classList.toggle('active');
        }
    </script>
</body>

</html>